package Game

import NetGraphAlgebraDefs.{NetGraph, NodeObject}
import GameLogic.Puppets.{graph, latestThiefNode}

import scala.collection.mutable
import scala.jdk.CollectionConverters.CollectionHasAsScala


//The following object serves as a storage for the helper functions used to produce the required statistics
object Statistics {

  /**
   * Function to calculate the distance to the nearest node with valuable data using Dijkstra's algorithm.
   *
   * @param node  The starting node for the Dijkstra's algorithm.
   * @param graph The graph on which Dijkstra's algorithm is performed.
   * @return A tuple containing the shortest distance and the path to the nearest valuable node.
   */
  def dijkstraShortestPath(node: NodeObject, graph: NetGraph): (Double, List[NodeObject]) = {

    // Data structures for Dijkstra's algorithm
    val distances = mutable.Map.empty[NodeObject, Double]
    val predecessors = mutable.Map.empty[NodeObject, Option[NodeObject]]
    val priorityQueue = mutable.PriorityQueue.empty(Ordering.by((nodeDistance: (NodeObject, Double)) => nodeDistance._2))
    val visited = mutable.Set.empty[NodeObject]

    // Initialize distances with infinity, except for the starting node
    graph.sm.asGraph().nodes().asScala.foreach { n =>
      distances(n) = if (n == node) 0 else Int.MaxValue
      predecessors(n) = None
    }

    // Enqueue the starting node
    priorityQueue.enqueue((node, 0))

    while (priorityQueue.nonEmpty) {
      val (current, currentDistance) = priorityQueue.dequeue()

      // Skip if the node has already been visited
      if (!visited.contains(current)) {
        visited.add(current)

        // Update distances for adjacent nodes
        graph.sm.adjacentNodes(current).asScala.foreach { neighbor =>

          // Weight of the edge
          val edgeWeight = latestThiefNode.storedValue
          val newDistance = currentDistance + edgeWeight

          if (newDistance < distances(neighbor)) {
            distances(neighbor) = newDistance
            predecessors(neighbor) = Some(current)
            priorityQueue.enqueue((neighbor, newDistance))
          }
        }
      }
    }

    // Find the minimum distance to a node with valuable data
    val valuableNodes = graph.sm.asGraph().nodes().asScala.filter(_.valuableData)
    val distancesToValuableNodes = valuableNodes.map(distances)

    if (distancesToValuableNodes.nonEmpty) {
      val shortestDistance = distancesToValuableNodes.min
      val pathToValuableNode = reconstructPath(node, predecessors, valuableNodes.minBy(distances))
      (shortestDistance, pathToValuableNode)
    } else {
      (Int.MaxValue, List.empty[NodeObject])
    }
  }

  /**
   * Helper function to reconstruct the path from source to destination.
   *
   * @param source       The source node of the path.
   * @param predecessors The map of predecessors generated by Dijkstra's algorithm.
   * @param destination  The destination node of the path.
   * @return The reconstructed path as a list of nodes.
   */
  private def reconstructPath(
                               source: NodeObject,
                               predecessors: mutable.Map[NodeObject, Option[NodeObject]],
                               destination: NodeObject
                             ): List[NodeObject] = {
    var current = destination
    var path = List.empty[NodeObject]

    while (predecessors.contains(current) && predecessors(current).nonEmpty) {
      path = current :: path
      current = predecessors(current).get
    }

    if (current == source) {
      path = source :: path
    }

    path
  }

  /**
   * Function to calculate the confidence score between original and perturbed nodes.
   *
   * @param original       The original node.
   * @param perturbed      The perturbed node.
   * @param perturbedGraph The graph with perturbed nodes.
   * @return The confidence score between original and perturbed nodes.
   */
  def calculateConfidenceScore(original: NodeObject, perturbed: NodeObject, perturbedGraph: NetGraph): Double = {

    // The number of edges in the original graph incident to the node
    val numOfEdgesInOriginal = graph.sm.asGraph().incidentEdges(original).size

    // Check if the node exists in the perturbed graph
    if (perturbedGraph.sm.nodes().contains(original)) {

      // If the node is present in the P-graph, the score is 1 by default
      var score = 1

      perturbedGraph.sm.asGraph().incidentEdges(original).forEach { edge =>

        // The edge must be also incident to the perturbed node in the original graph
        if (graph.sm.asGraph().incidentEdges(perturbed).contains(edge)
          && graph.sm.asGraph().degree(original) == perturbedGraph.sm.asGraph().degree(original)) {
          score += 1
        }
      }

      val result = if (numOfEdgesInOriginal > 0) math.min(1.0, score.toDouble / numOfEdgesInOriginal) else 0.0
      result
    } else {
      // Base case
      0.0
    }
  }
}
